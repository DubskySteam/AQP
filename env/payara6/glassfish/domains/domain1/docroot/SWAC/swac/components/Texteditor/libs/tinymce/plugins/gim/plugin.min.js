var jsonHandlerInformation = "faces/jsonInformation.xhtml";
var jsonHandlerMethodExecutor = "faces/jsonMethodsExecutor.xhtml";

// Load plugin specific language pack
tinymce.PluginManager.requireLangPack('gim', 'de');

//TODO
// Make undomanager entries for each action
// Get informations not used in content (and remove them from childs list)
// Split surrounding information nodes, if an dimension was removed

tinymce.PluginManager.add('gim', function (editor, url) {

    // Executed right after initialisation of editor
    editor.on("init", function (event) {
        // Load needed css
        //tinymce.activeEditor.dom.loadCSS('stylesheets/informations.css');
    });

    /** SECTION 1
     *	Register actions to events
     */

    var lastInsertSpan = null;			// Cache for insert-mode (Reference to last inserted content, surrounded by insert-mark-span)
    var autoParse = true;				// Sets if content should be auto parsed toggable with button (@see button mathml_autoparse)

    // Open context menue on right click
    editor.on("contextmenu", function (event) {
        // Get lenght of selected content
        var contentlength = tinymce.activeEditor.selection.getContent().length;

        // Prevent to open browsers default context menue
        event.preventDefault();
        // Prevent to open tinymce context menu
        //$('.mce-contextmenu').css({'visibility': 'hidden'});

        if (event.target.className.indexOf("inf_") !== -1 || event.target.className.indexOf("dim_") !== -1) {
            // Menu for existing informations
            renderExistingInformationMenu(event);
        } else if (contentlength > 0) {
            // If content selected show right click option for make information
            renderAddInformationMenu(event, editor);
        }

        // Show normal context menu (if plugin is activated)
        //$('.mce-contextmenu').css({'visibility': 'visible'});
    });

    // On mousedown: parse input if mousedown is out of the laste edited area
    editor.on('mousedown', function (event) {
        // Get selected node (not clicked node)
        var selectedNode = tinymce.activeEditor.selection.getNode();
        // Search for the node, which is the insert-mark
        var insertholderNode = searchParentNode('SPAN', 'inserted', selectedNode);
        // Parse input if insertholderNode and mathmlNode exists (no other conditions required)
        if (insertholderNode !== false) {
            var newcontent = parseInput(insertholderNode);
            // If dom not modified by parse insert new content and remove inserted-mark
            if (typeof newcontent != 'undefined' && newcontent !== '') {
                lastInsertSpan.innerHTML = newcontent;
                removeParentNodeKeepChilds('SPAN', 'inserted', selectedNode, true);
            }
            lastInsertSpan = null;
        }
    });

    // On keydown: Create spans arround new inserted content
    editor.on('keydown', function (event) {
        // get parent node
        var selectedNode = tinymce.activeEditor.selection.getNode();
        // if parent node is no span add span
        if ((selectedNode.nodeName !== 'SPAN' || selectedNode.className !== 'inserted') && keyCodeIsPrintable(event.keyCode)) {
            // Do not execute code here it prevents the entered key from positioned within the span
            tinyMCE.activeEditor.selection.setContent('<span class="inserted">');
        } else
        // If one of the special keys pressed execute parsing
        if (selectedNode.nodeName === 'SPAN' && selectedNode.className === 'inserted' && keyCodeStartsParse(event.keyCode)) {
            // Parsing is done right before surrounding span is removed (see editor.on('keyup'))
        }
    });

    // On keyup: Close spans arround new inserted content, parse inserted content
    editor.on('keyup', function (event) {
        var isShift;
        if (window.event) {
            isShift = !!window.event.shiftKey; // typecast to boolean
        } else {
            key = event.which;
            isShift = !!event.shiftKey;
        }

        // Work on last insertNode
        var selectedNode = tinymce.activeEditor.selection.getNode();
        if (lastInsertSpan === null) {
            // Remove placeholder
            removePlaceholderNode(selectedNode);
        }

        if (keyCodeIsPrintable(event.keyCode, isShift, autoParse)) {
//            alert('printable!');
            // If span not closed (normaly automatically closed by tinymce)
            tinyMCE.activeEditor.selection.setContent('</span>');
            lastInsertSpan = selectedNode;
        } else
        // If one of the special keys pressed remove span
        if (lastInsertSpan !== null && keyCodeStartsParse(event.keyCode, isShift, autoParse)) {
//            alert('starts parse!' + event.keyCode);
            var newcontent = parseInput(lastInsertSpan);
            if (typeof newcontent !== 'undefined' && newcontent !== '') {
                lastInsertSpan.innerHTML = newcontent + ' ';

            }
            removeParentNodeKeepChilds('SPAN', 'inserted', lastInsertSpan, false);
            lastInsertSpan = null;
        } else {
            lastInsertSpan = selectedNode;
        }

        // Update document statistic
        showDocumentStatistic();
    });

    // On click: Show information or dimension details or overview
    editor.on("click", function (evt) {
        console.log(evt);
        var classNames = evt.target.className;
        var classNamesArr = classNames.split(' ');

        if (classNames.indexOf("inf_") !== -1) {
            // Show information about information
            var id_parts = classNamesArr[2].split('_');
            showInformation(id_parts[0], id_parts[1], '');
            $('#infoPanelInformationViewTabs ul li a[href$="j_idt78"]').click();
        } else if (classNames.indexOf("dim_") !== -1) {
            // Show information about dimension
            var parentClassNames = evt.target.parentNode.className;
            var parentClassNamesArr = parentClassNames.split(' ');

            var id_parts = parentClassNamesArr[2].split('_');
            // Get class name withoud special marks
            var dim_classNames = evt.target.className.replace(' dim_inncorrect', '');
            var dim_parts = dim_classNames.split('_');
            showInformation(id_parts[0], id_parts[1], dim_parts[1]);
            $('#infoPanelInformationViewTabs ul li a[href$="j_idt78"]').click();
        } else if (classNames.indexOf("gim_dimselection") !== -1) {
            renderDimSelectionMenu(evt);
        } else {
            // TextAnalysis
            let ta = new TextAnalysis();
            // Get word on actual position
            let pos = evt.rangeOffset;
            ta.setText(evt.rangeParent.textContent);
            let word = ta.getWordAtPosition(pos);
            console.log('found word: ' + word);

            // Update document statistic
//            showDocumentStatistic();
//            $('#infoPanelInformationViewTabs ul li a[href$="j_idt118"]').click();
        }

    });

    /** SECTION 2
     *	Definition of buttons
     */

    editor.ui.registry.addButton('im_document_save', {
        text: 'IM_DOCUMENT_SAVE',
        icon: false,
        onclick: function () {
            alert(tinymce.activeEditor.getContent());
        }
    });

    editor.ui.registry.addButton('im_document_statistic', {
        text: 'IM_DOCUMENT_STATISTIC',
        icon: false,
        onclick: function () {
            document.getElementById('infopanelLayoutUnit').innerHTML = '<div id="im_statistic"></div>';
            documentStatistic();
        }
    });

    editor.ui.registry.addButton('im_document_analyse', {
        text: 'IM_DOCUMENT_ANALYSE',
        icon: false,
        onclick: function () {
            documentAnalyse();
        }
    });

    editor.ui.registry.addButton('im_document_check', {
        text: 'IM_DOCUMENT_CHECK',
        icon: false,
        onclick: function () {
            documentCheck();
        }
    });

    editor.ui.registry.addButton('im_document_metainfo', {
        text: 'IM_DOCUMENT_METAINFO',
        icon: false,
        onclick: function () {
            editor.windowManager.open({
                title: "docmetainfo_title",
                url: 'http://127.0.0.1/InformationManager/Services/InformationManager/index.php?information_id=' + editor.id,
                width: 700,
                height: 600
            });
        }
    });

    editor.ui.registry.addButton('im_options', {
        type: 'menubutton',
        text: 'IM_OPTIONS',
        icon: false,
        menu: [
            {text: 'Menu item 1', onclick: function () {
                    editor.insertContent('Menu item 1');
                }},
            {text: 'Menu item 2', onclick: function () {
                    editor.insertContent('Menu item 2');
                }}
        ]
    });



//			editor.on('click', function(e) {
//			if (e.target.className == "test-test-word") {
//				alert('right');
//				return false;
//				e.preventDefault();

    //var rng = selectMatch(e.target.getAttribute('data-mce-index'));
//				showSuggestions(e.target, 'test');
//			}
//		});

});